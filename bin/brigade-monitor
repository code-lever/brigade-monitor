#!/usr/bin/env ruby

require 'awesome_print'
require 'brigade/monitor'
require 'cgminer/api'
require 'optparse'
require 'yaml'

me = File.basename(__FILE__)

options = {}
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{me} [options]"
  opts.on('-c', '--config FILE', String, 'Configuration file') do |c|
    options[:config] = c
  end
  opts.on('-k', '--key API-KEY', String, 'Brigade API key') do |key|
    options[:key] = key
  end
  opts.on('-v', '--version', 'Print application version') do
    puts "#{me} v#{Brigade::Monitor::VERSION}"
    exit
  end
end.parse!

fail 'Configuration file is required' unless options[:config]

begin
  config = YAML.load(open(options[:config]).read)
rescue
  fail 'An error occurred parsing configuration file'
end

key = options.fetch(:key, config['api-key'])
fail 'Brigade API key is required' if key.nil?

# XXX connect once, check API key validity

# build a hash-o-miner clients
miners = config['miners'].map do |miner|
  {
    name: miner[0],
    client: CGMiner::API::Client.new(miner[1]['host'], miner[1]['port'])
  }
end

api = Brigade::Monitor::API.new(key)
loop do

  updates = []

  miners.each do |miner|
    begin
      summary = miner[:client].summary
      devs = miner[:client].devs
      pools = miner[:client].pools

      # XXX check status replies on each command?

      update = {
        host: miner[:name],
        uptime: summary.body[0]['Elapsed'] / 60,
        mhash: summary.body[0]['MHS 5s'],
        rejectpct: summary.body[0]['Pool Rejected%'],
        asics: [],
        fpgas: [],
        gpus: [],
        pools: []
      }

      devs.body.each do |dev|
        if dev.has_key? 'GPU'
          update[:gpus] << {
            temperature: dev['Temperature'],
            enabled: dev['Enabled'] == 'Y',
            status: :ok,                            # XXX enumerate statuses
            uptime: dev['Device Elapsed'] / 60,
            mhash: dev['MHS 5s'],
            rejectpct: dev['Device Rejected%']
          }
        else
          puts "Skipped device: #{dev}"
        end
      end

      pools.body.each do |pool|
        update[:pools] << {
          url: pool['URL'],
          status: :ok,                              # XXX enumerate statuses
          active: pool['Stratum Active'],
          rejectpct: pool['Pool Rejected%']
        }
      end

      updates << update
    rescue Net::OpenTimeout
      puts "Timed out: #{miner}"
      # XXX put something in the update to indicate it barfed
    rescue Exception => e
      puts "Some other error: #{miner} (#{e.class})"
      # XXX put something in the update to indicate it barfed
    end
  end

  response = api.hosts(updates)
  puts response.code

  sleep 60

end
